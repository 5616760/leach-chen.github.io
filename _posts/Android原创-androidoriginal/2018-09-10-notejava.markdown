---
layout: post
title: Java摘记
date:  2018-05-20 16:38:00 +0900  
description: Java摘记
img: post-10.jpg # Add image post (optional)
tags: [Android]
author: # Add name author (optional)
androidoriginal: true
---

## JVM概念 ##

### **1. GC机制** ###

垃圾回收分为两个过程，一个是找到垃圾，一个是回收垃圾

**找到垃圾有两种方法：**

1.引用计数法 <br>
当一个对象被引用时，其引用计数就会加1，当垃圾回收时，就会清空其引用计数变为0，但两个对象相互引用时，就会导致引用计数不为0，无法清理的情况，于是就有另外一种方法

2.可达性分析法 <br>
把Java中对象的引用关系链接起来，不可达根级对象的对象会被垃圾收集器清除，根级对象一般包括Java虚拟机中栈中对象，本地方法JNI栈中的对象，方法区中的静态对象，常量池中的常量

**垃圾回收的四种方法：**

1.标记清除算法 <br>
首先标记要清除的对象，然后进行清除，缺点是会造成内存碎片化

2.复制算法 <br>
将存活的对象复制到另一块内存区域，并做相应的内存整理工作。复制算法的优点可以避免内存碎片化，但内存需要双倍

3.标记整理算法 <br>
将要回收的垃圾对象进行标记，清除掉垃圾对象后，会对存活的对象进行压缩整理，避免了内存碎片化

4.分代算法 <br>
将对象分为新生对象和老年代对象，新生代对象分为三个区，Eden和两个Survivor区，新建的对象放在Eden区，当Eden区的对象达到阀值后会触发Minor GC，然后会将存活的对象复制到一个Survivor区，这些存活的对象生命存活计数会加1.这是Eden区会闲置，当Eden区的对象再次到达阀值时会触发Minor GC，这是会将Eden和这个Survivor区的对象复制到另一个Survivor区，这些存活的对象生命存活计数又会加1。重复以上过程，对象的生命存活计数达到阀值时，会将该对象放到老年代中。老年代中是多次GC依然存活的生命周期较长的对象，当老年代中对象达到阀值时就会触发Minor GC，采用标记整理算法进行处理。


### **2. JVM内存区域的划分** ###

JVM内存区域可以分为两类，线程的私有区域和公有区域。

线程的私有区域：**程序计数器、JVM虚拟机栈、本地方法栈**

线程的公有区域：**堆、方法区、运行时常量池**

程序计数器：每个线程有个私有的程序计数器,任何时间线程只有一个方法在执行，程序计数器执行的就是当前方法的JVM地址。

JVM虚拟机栈：栈中存放着一个个的栈帧，对应着一个个方法的调用。栈帧中存放着局部变量表、方法返回值、方法正常和异常退出的定义等等。

本地方法栈：类似虚拟机栈，支持的是Native方法。

堆：用来存放对象实例，几乎所有创建的对象都会分配到堆上，堆作为垃圾回收最主要的区域。

方法区：方法区主要存放类的结构信息，比如静态属性和方法等。

运行时常量池：运行时常量池位于方法区，存放各种常量信息。

**发生OOM区域：**

其中除了程序计数器，其它地方都会发生OOM，堆区对象引用释放不及时造成内存泄漏，栈区，方法递归调用可能导致栈空间扩展失败导致OOM，方法区如果在内存加载时，做的事情过多也会导致OOM。

### **3. 类的加载过程** ###

Java中类的加载分为加载、链接、初始化三个过程。

加载，是将字节码（jar文件，class文件）数据读取到JVM内存，并映射为JVM认可的数据结构，如果数据不是ClassFile的结构，则会报ClassFormatError。

## 线程概念 ##

## 网络概念 ##

## 其它 ##
